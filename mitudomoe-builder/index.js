// Generated by CoffeeScript 1.8.0
var Coffee, Context, Path, Q, build, getAllItemsInContext, injectFramework, map, options, processResource, processSceneario, processSource, result;

Context = require('mitudomoe').Context;

Q = require('q');

Path = require('path');

Coffee = require('coffee-script');

map = function(fn) {
  return function(items) {
    var item;
    return Q.all((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        _results.push(fn(item));
      }
      return _results;
    })());
  };
};

build = function(options) {
  var app;
  app = null;
  return getAllItemsInContext(options["in"]).then(map(function(item) {
    return processSource(item, options);
  })).then(function() {
    return injectFramework(options.out);
  }).then(function() {
    var Compiler, configure;
    Compiler = require(options.out.resolve('node_modules', 'mitudomoe')).Compiler;
    app = new Compiler;
    configure = (function() {
      try {
        return require(options.out.resolve('./configure'));
      } catch (_error) {}
    })();
    if (!configure) {
      throw "Cannot find 'configure.js' at the root of the project ";
    }
    configure(app);
    return app.preBuild(options["in"], options.out);
  }).then(function() {
    return getAllItemsInContext(options["in"]);
  }).then(map(function(item) {
    return processResource(item, app, options);
  }));
};

getAllItemsInContext = function(context) {
  return context.readDir('./').then(map(function(name) {
    return context.stat(name).then(function(stats) {
      var subContext;
      if (stats.isDirectory() && name === 'node_modules') {
        return {
          type: 'node_modules',
          name: name,
          context: context
        };
      } else if (stats.isDirectory()) {
        subContext = context.subContext(name);
        return getAllItemsInContext(subContext).then(function(items) {
          return {
            type: 'folder',
            name: name,
            context: context,
            items: items
          };
        });
      } else {
        return {
          type: 'file',
          name: name,
          context: context
        };
      }
    });
  }));
};

processSource = function(item, options) {
  var inContext, inPath, outContext, outPath, relativePath;
  inContext = options["in"];
  outContext = options.out;
  relativePath = inContext.relative(item.context.path);
  switch (item.type) {
    case 'node_modules':
      return inContext.copy(inContext.resolve(relativePath, item.name), outContext.resolve(relativePath, item.name));
    case 'folder':
      return Q.all((function() {
        var _i, _len, _ref, _results;
        _ref = item.items;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(processSource(item, options));
        }
        return _results;
      })());
    case 'file':
      switch (Path.extname(item.name).toLowerCase()) {
        case '.coffee':
          return item.context.getContent(item.name).then(function(content) {
            var compiled, filename;
            compiled = Coffee.compile(content);
            filename = Path.basename(item.name.toLowerCase(), '.coffee') + '.js';
            return outContext.write(outContext.resolve(relativePath, filename), compiled);
          });
        case '.js':
          inPath = inContext.resolve(relativePath, item.name);
          outPath = outContext.resolve(relativePath, item.name);
          return inContext.copy(inPath, outPath);
      }
  }
};

processResource = function(item, app, options) {
  var inPath, outPath, relativePath, subItem;
  if (item.type === 'folder') {
    return Q.all((function() {
      var _i, _len, _ref, _results;
      _ref = item.items;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subItem = _ref[_i];
        _results.push(processResource(subItem, app, options));
      }
      return _results;
    })());
  } else if (Path.extname(item.name) === '.scene') {
    return processSceneario(item, app, options);
  } else {
    relativePath = options["in"].relative(item.context.path);
    inPath = options["in"].resolve(relativePath, item.name);
    outPath = options.out.resolve(relativePath, item.name);
    return options["in"].copy(inPath, outPath);
  }
};

processSceneario = function(item, app, options) {
  var inPath, outPath, relativePath;
  if (Path.extname(item.name) !== '.scene') {
    return null;
  }
  relativePath = options["in"].relative(item.context.path);
  inPath = options["in"].resolve(relativePath, item.name);
  outPath = options.out.resolve(relativePath, item.name);
  return options["in"].getContent(inPath).then(function(content) {
    var compiled;
    compiled = app.compile(content, item.context);
    return options.out.write(outPath, JSON.stringify(compiled));
  });
};

injectFramework = function(targetContext) {
  var frameworkPath;
  frameworkPath = Path.resolve(__dirname, 'node_modules', 'mitudomoe');
  return targetContext.copy(frameworkPath, targetContext.resolve('node_modules', 'mitudomoe'));
};

if (require.main === module) {
  options = require('commander');
  options.option('-i, --in [input]', 'Input folder').option('-o, --out [output]', 'Output folder').parse(process.argv);
  if (!options["in"] || !options.out) {
    throw 'No input folder or output folder specified';
  }
  options["in"] = new Context(Path.resolve(process.cwd(), options["in"]));
  options.out = new Context(Path.resolve(process.cwd(), options.out));
  result = build(options);
  result.fail(function(err) {
    return console.log('shit', err);
  });
  result.done(function() {
    return console.log('done');
  });
} else {
  module.exports = {
    build: build,
    Context: Context
  };
}
