// Generated by CoffeeScript 1.8.0
var BaseSyntax, DependencySyntax, Lexer, Mitudomoe, Parser, RegexSyntax,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

BaseSyntax = require('functional-parser/syntax/base');

RegexSyntax = require('functional-parser/syntax/regex');

Lexer = require('functional-parser/parser').Lexer;

Parser = require('../core/compiler').Parser;

Mitudomoe = require('../core/mitudomoe');

DependencySyntax = (function(_super) {
  __extends(DependencySyntax, _super);

  DependencySyntax.prototype.openRegex = /#import\s*/;

  DependencySyntax.prototype.filenameRegex = /[^\s\n]+/;

  function DependencySyntax() {
    DependencySyntax.__super__.constructor.apply(this, arguments);
    this.context = null;
    this.subLexer = new Lexer;
    this.importStack = [];
    this.subLexer.addSyntax(new RegexSyntax(this.openRegex, function() {
      return 'IMPORT_MARK';
    }));
    this.subLexer.addSyntax(new RegexSyntax(this.filenameRegex, function() {
      return 'IMPORT_FILE';
    }));
  }

  DependencySyntax.prototype.lexingStep = function(input) {
    var first, firstText, second, secondText;
    this.subLexer.setInput(input);
    first = this.subLexer.lex();
    if (first !== 'IMPORT_MARK') {
      return false;
    }
    firstText = this.subLexer.yytext;
    second = this.subLexer.lex();
    if (second !== 'IMPORT_FILE') {
      return false;
    }
    secondText = this.subLexer.yytext;
    this.yytext = [firstText, secondText];
    return [first, second];
  };

  DependencySyntax.prototype.grammar = function(bnf) {
    return {
      STATE: [
        this.pattern('IMPORTED_STATE', function() {
          return $1;
        })
      ],
      IMPORTED_STATE: [
        this.pattern('IMPORT_MARK IMPORT_FILE', function() {
          return yy.importFile($2);
        })
      ]
    };
  };

  DependencySyntax.prototype.bridge = function() {
    return {
      importFile: (function(_this) {
        return function(filename) {
          var circularText, content, lexer, parser, state, states, syntax, _i, _j, _len, _len1, _ref, _ref1, _ref2;
          if (__indexOf.call(_this.importStack, filename) >= 0) {
            circularText = _this.importStack.join(' --> ') + ' --> ' + filename;
            throw "Circular import is not supported " + circularText;
          }
          _this.importStack.push(filename);
          content = (_ref = _this.context) != null ? _ref.getContent(filename) : void 0;
          lexer = _this.lexer;
          parser = new Parser;
          _ref1 = lexer.syntaxes;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            syntax = _ref1[_i];
            parser.addSyntax(syntax);
          }
          states = parser.parse(content);
          _this.importStack.pop();
          state = Mitudomoe.mergeStates(states);
          _ref2 = lexer.syntaxes;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            syntax = _ref2[_j];
            syntax.lexer = lexer;
          }
          return state;
        };
      })(this)
    };
  };

  return DependencySyntax;

})(BaseSyntax);

module.exports = {
  Syntax: DependencySyntax
};
