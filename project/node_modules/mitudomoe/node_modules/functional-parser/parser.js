// Generated by CoffeeScript 1.8.0
var Jison, Lexer, Parser, fs,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Jison = require('jison');

fs = require('fs');

Lexer = (function() {
  function Lexer() {
    this.remainingText = __bind(this.remainingText, this);
    this.dequeue = __bind(this.dequeue, this);
    this.lex = __bind(this.lex, this);
    this.setInput = __bind(this.setInput, this);
    this.syntaxes = [];
    this.setInput("");
  }

  Lexer.prototype.addSyntax = function(syntax) {
    if (__indexOf.call(this.syntaxes, syntax) < 0) {
      this.syntaxes.push(syntax);
    }
    return syntax.lexer = this;
  };

  Lexer.prototype.setInput = function(input) {
    this.input = input;
    this.yytext = "";
    this.index = 0;
    this.tokens = [];
    return this.queue = [];
  };

  Lexer.prototype.lex = function() {
    var capturedText, currentText, index, obj, objs, queued, syntax, thisToken, token, _i, _j, _len, _len1, _ref;
    if (queued = this.dequeue()) {
      return queued.token;
    }
    currentText = this.remainingText();
    if (!currentText) {
      return "EOF";
    }
    _ref = this.syntaxes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      syntax = _ref[_i];
      thisToken = syntax.lexingStep(currentText);
      if (!thisToken) {
        continue;
      }
      capturedText = syntax.yytext;
      if (!(thisToken instanceof Array)) {
        thisToken = [thisToken];
        capturedText = [capturedText];
      }
      objs = (function() {
        var _j, _len1, _results;
        _results = [];
        for (index = _j = 0, _len1 = thisToken.length; _j < _len1; index = ++_j) {
          token = thisToken[index];
          _results.push({
            token: token,
            text: capturedText[index]
          });
        }
        return _results;
      })();
      for (_j = 0, _len1 = objs.length; _j < _len1; _j++) {
        obj = objs[_j];
        this.queue.push(obj);
      }
      return this.dequeue().token;
    }
    return 'INVALID';
  };

  Lexer.prototype.dequeue = function() {
    var thisObj;
    if (!this.queue.length) {
      return false;
    }
    thisObj = this.queue.shift();
    this.yytext = thisObj.text;
    this.index += this.yytext.length;
    this.tokens.push(thisObj.token);
    return thisObj;
  };

  Lexer.prototype.remainingText = function() {
    return this.input.substr(this.index);
  };

  return Lexer;

})();

Parser = (function() {
  function Parser() {
    this.bnf = {
      FILE: [['STATES EOF', 'return $1']],
      STATES: [['STATE', '$$ = [$1]'], ['STATES STATE', 'if($2)$1.push($2)']]
    };
    this.lexer = new Lexer;
    this.yy = {};
  }

  Parser.prototype.addGrammar = function(fn) {
    var token, tokens, value, _results;
    tokens = typeof fn === "function" ? fn(this.bnf) : void 0;
    _results = [];
    for (token in tokens) {
      value = tokens[token];
      if (token in this.bnf) {
        _results.push(this.bnf[token] = this.bnf[token].concat(value));
      } else {
        _results.push(this.bnf[token] = value);
      }
    }
    return _results;
  };

  Parser.prototype.addSyntax = function(syntax) {
    var bridge, fn, key, _ref, _results;
    this.lexer.addSyntax(syntax);
    this.addGrammar((_ref = syntax.grammar) != null ? typeof _ref.bind === "function" ? _ref.bind(syntax) : void 0 : void 0);
    bridge = typeof syntax.bridge === "function" ? syntax.bridge() : void 0;
    _results = [];
    for (key in bridge) {
      fn = bridge[key];
      _results.push(this.yy[key] = fn);
    }
    return _results;
  };

  Parser.prototype.parse = function(text) {
    var grammar, js, parser;
    grammar = {
      bnf: this.bnf,
      operators: [["left", ":"]]
    };
    parser = new Jison.Parser(grammar);
    parser.yy = this.yy;
    parser.lexer = this.lexer;
    js = parser.generate();
    fs.writeFileSync('./wowowow.js', js);
    return parser.parse(text);
  };

  return Parser;

})();

module.exports = {
  Lexer: Lexer,
  Parser: Parser
};
