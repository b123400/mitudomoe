// Generated by CoffeeScript 1.8.0
var BaseSyntax, Lexer, RegexSyntax, SettingSyntax,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

BaseSyntax = require('./base');

RegexSyntax = require('./regex');

Lexer = require('../parser').Lexer;

SettingSyntax = (function(_super) {
  __extends(SettingSyntax, _super);

  SettingSyntax.prototype.regex = {
    dash: /[\s]*-+[\s]*/,
    string: /[^:\s,]+/,
    comma: /[\s]*,[\s]*/,
    colonRegex: /[\s]*:[\s]*/
  };

  function SettingSyntax(callback) {
    var s, _i, _len, _ref;
    this.callback = callback;
    SettingSyntax.__super__.constructor.apply(this, arguments);
    this.dashSyntax = new RegexSyntax(this.regex.dash, function() {
      return '-';
    });
    this.stringSyntax = new RegexSyntax(this.regex.string, function() {
      return 'SETTING_STRING';
    });
    this.commaSyntax = new RegexSyntax(this.regex.comma, function() {
      return ',';
    });
    this.colonSyntax = new RegexSyntax(this.regex.colonRegex, function() {
      return ':';
    });
    this.subLexer = new Lexer;
    _ref = [this.dashSyntax, this.colonSyntax, this.commaSyntax, this.stringSyntax];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      this.subLexer.addSyntax(s);
    }
  }

  SettingSyntax.prototype.lexingStep = function(input) {
    var close, dashCount, i, lexed, middle, open, results, yytexts, _i;
    this.subLexer.setInput(input);
    results = [];
    yytexts = [];
    i = 0;
    dashCount = 0;
    while (lexed = this.subLexer.lex()) {
      if (lexed === 'INVALID' || lexed === 'EOF') {
        break;
      }
      results.push(lexed);
      yytexts.push(this.subLexer.yytext);
      if (lexed === '-') {
        dashCount++;
      }
      if (dashCount === 2) {
        break;
      }
      i++;
    }
    if (results.length === 0) {
      return false;
    }
    open = results[0], middle = 3 <= results.length ? __slice.call(results, 1, _i = results.length - 1) : (_i = 1, []), close = results[_i++];
    if (open !== '-' || close !== '-' || !middle.every(function(x) {
      return x === 'SETTING_STRING' || x === ':' || x === ',';
    })) {
      return false;
    }
    this.yytext = yytexts;
    return results;
  };

  SettingSyntax.prototype.grammar = function(bnf) {
    return {
      STATE: [
        this.pattern("SETTING", function() {
          return $1;
        })
      ],
      SETTING: [
        this.pattern("- SETTING_KEY : SETTING_VALUE -", function() {
          var key, obj;
          obj = {};
          key = $2;
          obj[key] = $4;
          yy.receivedSetting($2, $4);
          return obj;
        })
      ],
      SETTING_KEY: [
        this.pattern("SETTING_STRING", function() {
          return $1;
        })
      ],
      SETTING_VALUE: [
        this.pattern("SETTING_STRING", function() {
          return [$1];
        }), this.pattern("SETTING_VALUE , SETTING_STRING", function() {
          return $1.concat($3);
        })
      ]
    };
  };

  SettingSyntax.prototype.bridge = function() {
    return {
      receivedSetting: (function(_this) {
        return function(key, values) {
          return typeof _this.callback === "function" ? _this.callback(key, values) : void 0;
        };
      })(this)
    };
  };

  return SettingSyntax;

})(BaseSyntax);

module.exports = SettingSyntax;
