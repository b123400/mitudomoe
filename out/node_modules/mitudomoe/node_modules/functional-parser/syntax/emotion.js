// Generated by CoffeeScript 1.8.0
var BaseSyntax, CharacterSyntax, EmotionSyntax, Lexer, RegexSyntax,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseSyntax = require('./base');

RegexSyntax = require('./regex');

CharacterSyntax = require('./character');

Lexer = require('../parser').Lexer;

EmotionSyntax = (function(_super) {
  __extends(EmotionSyntax, _super);

  EmotionSyntax.prototype.regex = {
    open: /[\s]*\([\s]*/,
    close: /[\s]*\)[\s]*/,
    comma: /[\s]*,[\s]*/,
    string: /[^,\(\)]+/
  };

  function EmotionSyntax() {
    var s, _i, _len, _ref;
    EmotionSyntax.__super__.constructor.apply(this, arguments);
    this.openSyntax = new RegexSyntax(this.regex.open, function() {
      return '(';
    });
    this.closeSyntax = new RegexSyntax(this.regex.close, function() {
      return ')';
    });
    this.commaSyntax = new RegexSyntax(this.regex.comma, function() {
      return ',';
    });
    this.stringSyntax = new RegexSyntax(this.regex.string, function() {
      return 'EMOTION_NAME';
    });
    this.subLexer = new Lexer;
    _ref = [this.openSyntax, this.closeSyntax, this.commaSyntax, this.stringSyntax];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      this.subLexer.addSyntax(s);
    }
  }

  EmotionSyntax.prototype.lexingStep = function(input) {
    var colonMatch, lexed, r, results;
    if (this.lastToken() !== 'CHARACTER_NAME') {
      return false;
    }
    this.subLexer.setInput(input);
    results = [];
    while (lexed = this.subLexer.lex()) {
      if (lexed === 'INVALID') {
        return false;
      } else {
        results.push({
          lexed: lexed,
          yytext: this.subLexer.yytext
        });
        if (lexed === ')') {
          break;
        }
      }
    }
    if (results.length === 0) {
      return false;
    }
    colonMatch = CharacterSyntax.prototype.colonRegex.exec(this.subLexer.remainingText());
    if ((colonMatch != null ? colonMatch.index : void 0) === 0) {
      results.push({
        lexed: ':',
        yytext: colonMatch[0]
      });
    }
    this.yytext = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        r = results[_i];
        _results.push(r.yytext);
      }
      return _results;
    })();
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        r = results[_i];
        _results.push(r.lexed);
      }
      return _results;
    })();
  };

  EmotionSyntax.prototype.grammar = function() {
    return {
      CHARACTER: [
        this.pattern("CHARACTER_NAME ( EMOTION_NAME_LIST )", function() {
          return {
            name: $1,
            emotions: $3
          };
        })
      ],
      "EMOTION_NAME_LIST": [
        this.pattern("EMOTION_NAME", function() {
          return [$1];
        }), this.pattern("EMOTION_NAME_LIST , EMOTION_NAME", function() {
          return $1.concat($3);
        })
      ]
    };
  };

  return EmotionSyntax;

})(BaseSyntax);

module.exports = EmotionSyntax;
